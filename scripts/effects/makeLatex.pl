#!/usr/bin/perl

use strict;
use Data::Dumper;


######################################################################
# CONFIGURATION

# 1) Which CSVs were generated by table-generator
my @resultsfiles = (
    #"results/benchmark-coarmochi.2024-02-25_10-16-09.results.default.mochibenchmarks.csv",
    #"results/benchmark-coarmochi.2024-03-25_16-47-09.results.default.mochibenchmarks.csv",
    #"results/benchmark-coarmochi.2024-04-03_12-51-55.results.default.mochibenchmarks.csv",
    #"results/benchmark-coarmochi.2024-05-09_09-54-42.results.default.mochibenchmarks.csv",
    "results/benchmark-coarmochi.2024-07-02_17-08-26.results.default.mochibenchmarks.csv",
    "results/benchmark-realmochi.2024-XXXXXX.results.default.realmochibenchmarks.csv",
    #"results/results.2024-04-04_10-01-41.table.csv"
    #"results/results.2024-06-30_11-29-24.table.csv"
    "results/results.2024-07-02_16-55-09.table.csv"
);

# 2) load the RunDefinitions defined in the autogen XML file
my @RUNDEFINITIONS = ('default.mochibenchmarks','default.realmochibenchmarks');
# open T, "benchmark-drift-autogenerated.xml" or die $!;
# while(<T>) {
#     if (/rundefinition name="([^"]+)">/) {
#         push @RUNDEFINITIONS, $1;
#     }
# }
# close T;
# print "- loaded rundef names: ".join(", ", @RUNDEFINITIONS)."\n";

# 3) which one to use for mochi?
my $COARMOCHI_RD = 'default.mochibenchmarks';
my $REALMOCHI_RD = 'default.realmochibenchmarks';

# 4) Give human-readible names for these rundefinitions for column headers:
sub run2tool {
    my ($rdName) = @_;
    return 'CPS+COaRRCaml' if $rdName eq 'default.mochibenchmarks';
    return 'Tuple+Mochi' if $rdName eq 'default.realmochibenchmarks';
    if($rdName =~ /NOTE(.*)-TL(.*)-TP(.*)-TH(.*)-DM(.*)-TR([^\.]*)(\.effects)?/) {
        my $tp = ($3 eq 'true' ? 'T' : 'F');
        my $th = ($4 eq 'true' ? 'T' : 'F');
        my $isTrans = $6;
        return "\\humanCfg".$isTrans."{$1}{$2}{$tp}{$th}{$5}"
    } else {
        die "don't know how to parse rundef: $rdName\n";
    }
}
my %dm2domain = (
    ls => 'Polka_ls',
    st => 'Polka_st',
    pg => 'PolkaGrid',
    oct => 'Octagon',
);
sub cfg2cmd {
    my ($subdir,$benchname, $cfg) = @_;
    if ($cfg =~ /TL([^-]+)-TP([^-]+)-TH([^-]+)-DM([^-]+)-TR([^-]+)\.effects/) {
        my ($tl,$tp,$th,$dm,$tr) = ($1,$2,$3,$4,$5);
        return join(' ', (
            './drift.exe',
            '-file', "tests/effects/$subdir$benchname.ml",
            '-prop', "tests/effects/$subdir$benchname.yml.prp",
            '-ev-trans', $tr,
            '-trace-len', $tl,
            '-if-part', $tp,
            '-out', 0,
            '-domain', $dm2domain{$dm},
            '-thold', $th
        ))."\n";
    }
}
# my %run2tool = (
#     'drift-new-len0.effects' => 'EDrift len0',
#     'drift-new-len1.effects' => 'EDrift len1',
#     'drift-trans-len0.effects' => 'Trans+Drift len0',
#     'drift-trans-len1.effects' => 'Trans+Drift len1',
#     'default.mochibenchmarks' => 'CPS+Mochi',
#     'CA-March20.effects' => '3/20/24 TP',
#     'CA-March20-trans.effects' => '3/20/24 TP + trans'
# );
######################################################################
use List::Util qw(product);
use Math::Complex;
sub geometric_mean {
    my @numbers = @_; # Get the list of integers passed to the function
    return 0 unless @numbers; # Return 0 if the list is empty

    my $product = product(@numbers); # Calculate the product of all integers in the list
    my $n = scalar @numbers; # Count the total number of integers
    return sprintf("%0.1f", exp(log($product)/$n));
}
######################################################################

sub cleanRes {
    my ($r) = @_;
    return '\Chk' if $r eq 'true';
    return '\TO' if $r eq 'TIMEOUT';
    return '\MO' if $r eq 'OUT OF MEMORY';
    return '\Unk' if $r eq 'unknown';
    return '\ERR' if $r eq 'ERROR (1)';
    return $r;    
}


my $d;
sub parseResultsFile {
    my ($fn) = @_;
    open F, $fn or die "opening $fn - $!";
    # unfortunately the mochi output is a little different (one fewer column) then the other CSV
    die "TODO parseResultsFile decide based on $fn";
    my $isCoarMochi = ($fn =~ /mochi/ ? 1 : 0);
    my $isRealMochi = ($fn =~ /mochi/ ? 1 : 0);

    my @runSets; 
    while(<F>) {
        next if /\tstatus\t/;
        next if /^tool/;
        if (/^run set/) {
            @runSets = split /\t/, $_;
            shift @runSets;
            shift @runSets unless ($isCoarMochi || $isRealMochi);

        } else {
            my ($bench,@RCWMs) = split /\t/, $_;
            # next if $bench =~ /lics18-web/;
            next if $bench =~ /higher-order-disj/;
            next if $bench =~ /traffic/;
            # next if $bench =~ /reentr/;
            # next if $bench =~ /temperature/;
            $bench =~ s/cps_// if $isCoarMochi;
            $bench =~ s/\.y?ml$//;
            shift @RCWMs unless ($isCoarMochi || $isRealMochi);
            for(my $i=0; $i <= $#RCWMs; $i+=4) {
                $d->{$bench}->{$runSets[$i]}->{res} = $RCWMs[$i];
                $d->{$bench}->{$runSets[$i]}->{cpu} = $RCWMs[$i+1];
                $d->{$bench}->{$runSets[$i]}->{wall} = $RCWMs[$i+2];
                $d->{$bench}->{$runSets[$i]}->{mem} = $RCWMs[$i+3];
                $d->{$bench}->{$runSets[$i]}->{rd}  = $runSets[$i];
#                push @RUNDEFINITIONS, $runSets[$i];
            }
            #my ($fn,$res,$cpu,$wall,$mem) = split /\t/, $_;
            # $fn =~ s/^cps_//;
            # $fn =~ s/_/\\_/g;
            # printf("%-30s & %-5s & %0.2f & %0.2f & %0.2f \\\\\n",
            #     $fn, cleanRes($res), $cpu, $wall, $mem);
        }
    }
}

foreach my $fn (@resultsfiles) {
    parseResultsFile($fn);
}


sub newBest {
    my ($BEST,$bench,$rd) = @_;
    $d->{$bench}->{$BEST}->{res}  = $d->{$bench}->{$rd}->{res};
    $d->{$bench}->{$BEST}->{cpu}  = $d->{$bench}->{$rd}->{cpu};
    $d->{$bench}->{$BEST}->{wall} = $d->{$bench}->{$rd}->{wall};
    $d->{$bench}->{$BEST}->{mem}  = $d->{$bench}->{$rd}->{mem};
    $d->{$bench}->{$BEST}->{rd}   = $rd;
}
# compute the best (non-mochi) run set (for Table 1)
foreach my $bench (sort keys %$d) {
    my $done = 0;
    foreach my $rd (keys %{$d->{$bench}}) {
        next if $rd =~ /BEST/;
        next if $rd =~ /mochi/i;
        # For Drift+Trans, don't allow Trace Partitioning
        next if $rd =~ /TRtrans/ && $rd =~ /TPtrue/;
#        next unless $d->{$bench}->{$rd}->{res} eq 'true';
        # which are we improving?
        my $BEST = ($rd =~ /trans/i ? 'BEST_TRANS' : 'BEST_DRIFTEV');
        # we have nothing yet, so we take it
        if ($d->{$bench}->{$BEST}->{rd} !~ /[a-z]/) {
            if ($BEST eq 'BEST_DRIFTEV') { ++$done; die "bad" if $done++ > 1; }
            newBest($BEST,$bench,$rd);
        # does it improve because previously BEST coudln't prove it?
        } elsif ($d->{$bench}->{$BEST}->{res} ne 'true') {
            newBest($BEST,$bench,$rd);
        # does it improve because it's faster?
        } elsif ($d->{$bench}->{$rd}->{res} eq 'true'
                && $d->{$bench}->{$rd}->{cpu} < $d->{$bench}->{$BEST}->{cpu}) {
            newBest($BEST,$bench,$rd);
        } else {
            # warn "not better\n";
        }
    }    
}
#print Dumper($d);

open EXT, ">exp-apx.tex" or die $!;
# print EXT "     ";
# foreach my $tool (@RUNDEFINITIONS) {
#     print EXT " & \\multicolumn{3}{|c||}{$run2tool{$tool}}";
# }
# print EXT "\\\\ \n";
# print EXT "{\\bf Bench} ";
# foreach my $tool (@RUNDEFINITIONS) {
#     print EXT " & {\\bf Res} & {\\bf CPU} & {\\bf Mem} ";
# }
# print EXT "\\\\ \n";
# print EXT "\\hline\n";
my $ct = 1;
foreach my $b (sort keys %$d) {
    my $tt = $b; $tt =~ s/\_/\\_/g;
    $tt =~ s/negated/neg/;
    print EXT "$ct. \\texttt{\\scriptsize $tt} \\\\\n"; ++ $ct;
    # sort the run defs by tool:
    my @driftRds = grep {$d->{$b}->{$_}->{rd} =~ /TRtrans/ } keys %{$d->{$b}};
    my @evdriftRds = grep {$d->{$b}->{$_}->{rd} =~ /TRdirect/ } keys %{$d->{$b}};
    foreach my $tool (@driftRds, @evdriftRds) { # @RUNDEFINITIONS) {
        next if $tool =~ /BEST/;
        my $drift = ($tool =~ /TRtrans/ ? '\drift' : '\evdrift');
        my $isBest = ($d->{$b}->{BEST_DRIFTEV}->{rd} eq $tool ? '\hl ' : '    ');
        print EXT sprintf("& $drift & $isBest %s & $isBest %-5s & $isBest %3.2f & $isBest %3.2f  \\\\\n",
           run2tool($tool),
           cleanRes($d->{$b}->{$tool}->{res}),
           $d->{$b}->{$tool}->{cpu},
#           $d->{$b}->{$tool}->{wall},
           $d->{$b}->{$tool}->{mem}); # d->{$b}->{$tool}->{rd}));
    }
    print  EXT "\\hline\n";
}
close EXT;
print "wrote: exp-apx.tex\n";

### Generate paper body table showing only the best

open BODY, ">exp-body.tex" or die $!;
open SCRIPT, ">generate_table1" or die $!;
open UNSAFE, ">runall_unsafe" or die $!;
# print BODY "     ";
# foreach my $tool (@RUNDEFINITIONS) {
#     print BODY " & \\multicolumn{3}{|c||}{$run2tool{$tool}}";
# }
# print BODY "\\\\ \n";
# print BODY "{\\bf Bench} ";
# foreach my $tool (@RUNDEFINITIONS) {
#     print BODY " & {\\bf Res} & {\\bf CPU} & {\\bf Mem} ";
# }
# print BODY "\\\\ \n";
# print BODY "\\hline\n";
my @geos_coarmochi; my @geos_realmochi; my @geos_evtrans; my @geos_direct;
my $newOverCoarMochi = 0; my $newOverRealMochi = 0; my $newOverTrans = 0; my $benchCount = 0; $ct = 1;
my $driftVerified = 0; my $evdriftVerified = 0;
my @bothSolved;
#print Dumper($d->{overview1});
foreach my $b (sort keys %$d) {
    # next if $b =~ /auction/;
    # next if $b =~ /binomial_heap/;
    # next if $b =~ /ho-shrink/; # old name;
    my $tt = $b; $tt =~ s/\_/\\_/g;
    $tt =~ s/negated/neg/;
    #warn "b: $b\n".Dumper($d->{$b});
    print BODY "$ct. \\texttt{\\scriptsize $tt} "; ++$ct;
    #warn "tool rd: ".Dumper($b,$d->{$b},$d->{$b}->{BEST_TRANS},$d->{$b}->{BEST_TRANS}->{rd});
    die "don't have a BEST_TRANS rundef for $b" unless $d->{$b}->{BEST_TRANS}->{rd} =~ /[a-z]/;
    die "don't have a $REALMOCHI_RD rundef for $b" unless $d->{$b}->{$REALMOCHI_RD}->{rd} =~ /[a-z]/;
    die "don't have a $COARMOCHI_RD rundef for $b" unless $d->{$b}->{$COARMOCHI_RD}->{rd} =~ /[a-z]/;
    die "don't have a BEST_DRIFTEV rundef for $b" unless $d->{$b}->{BEST_DRIFTEV}->{rd} =~ /[a-z]/;
    # Trans-Drift
    print BODY sprintf("& %-5s & %3.1f & %3.1f & %s ",
           cleanRes($d->{$b}->{BEST_TRANS}->{res}),
           $d->{$b}->{BEST_TRANS}->{cpu},
           $d->{$b}->{BEST_TRANS}->{mem},
           run2tool($d->{$b}->{BEST_TRANS}->{rd}));
    # Trans-COARMochi
    print BODY sprintf("& %-5s & %3.1f & %3.1f ",
           cleanRes($d->{$b}->{$COARMOCHI_RD}->{res}),
           $d->{$b}->{$COARMOCHI_RD}->{cpu},
           $d->{$b}->{$COARMOCHI_RD}->{mem});
    # Trans-Mochi
    print BODY sprintf("& %-5s & %3.1f & %3.1f ",
           cleanRes($d->{$b}->{$REALMOCHI_RD}->{res}),
           $d->{$b}->{$REALMOCHI_RD}->{cpu},
           $d->{$b}->{$REALMOCHI_RD}->{mem});
    # DriftEV
    print BODY sprintf("& %-5s & %3.1f & %3.1f & %s \\\\ \n",
           cleanRes($d->{$b}->{BEST_DRIFTEV}->{res}),
           $d->{$b}->{BEST_DRIFTEV}->{cpu},
           $d->{$b}->{BEST_DRIFTEV}->{mem},
           run2tool($d->{$b}->{BEST_DRIFTEV}->{rd}));
    printf "best EDrift result for %-40s : %-10s : %s\n", $b, $d->{$b}->{BEST_DRIFTEV}->{res}, $d->{$b}->{BEST_DRIFTEV}->{rd};
    # save the runtimes for statistics
    push @geos_evtrans, $d->{$b}->{BEST_TRANS}->{cpu}
      if $d->{$b}->{BEST_TRANS}->{res} eq 'true' && $d->{$b}->{BEST_TRANS}->{cpu} < 900 && $d->{$b}->{BEST_TRANS}->{cpu} > 0;
    push @geos_coarmochi, $d->{$b}->{$COARMOCHI_RD}->{cpu}
      if $d->{$b}->{$COARMOCHI_RD}->{res} eq 'true' && $d->{$b}->{$COARMOCHI_RD}->{cpu} < 900 && $d->{$b}->{$COARMOCHI_RD}->{cpu} > 0;
    push @geos_realmochi, $d->{$b}->{$REALMOCHI_RD}->{cpu}
      if $d->{$b}->{$REALMOCHI_RD}->{res} eq 'true' && $d->{$b}->{$REALMOCHI_RD}->{cpu} < 900 && $d->{$b}->{$REALMOCHI_RD}->{cpu} > 0;
    push @geos_direct, $d->{$b}->{BEST_DRIFTEV}->{cpu}
      if $d->{$b}->{BEST_DRIFTEV}->{res} eq 'true' && $d->{$b}->{BEST_DRIFTEV}->{cpu} < 900 && $d->{$b}->{BEST_DRIFTEV}->{cpu} > 0;
    #
    $driftVerified++ if $d->{$b}->{BEST_TRANS}->{res} eq 'true'; 
    $evdriftVerified++ if $d->{$b}->{BEST_DRIFTEV}->{res} eq 'true'; 
    $newOverCoarMochi++ if $d->{$b}->{BEST_DRIFTEV}->{res} eq 'true' && $d->{$b}->{$COARMOCHI_RD}->{res} ne 'true';
    $newOverRealMochi++ if $d->{$b}->{BEST_DRIFTEV}->{res} eq 'true' && $d->{$b}->{$REALMOCHI_RD}->{res} ne 'true';
    $newOverTrans++ if $d->{$b}->{BEST_DRIFTEV}->{res} eq 'true' && $d->{$b}->{BEST_TRANS}->{res} ne 'true';
    $benchCount++;
    # remember which ones were solved by Drift for speedup calculation
    push @bothSolved, $b if $d->{$b}->{BEST_TRANS}->{res} eq 'true' && $d->{$b}->{BEST_DRIFTEV}->{res} eq 'true';
    # script for drift and evdrift
    print SCRIPT "# Drift on $b:\n".cfg2cmd('',$b,$d->{$b}->{BEST_TRANS}->{rd});
    print SCRIPT "# evDrift on $b:\n".cfg2cmd('',$b,$d->{$b}->{BEST_DRIFTEV}->{rd});
    #print UNSAFE "# Drift on $b:\n".cfg2cmd('unsafe/',$b,$d->{$b}->{BEST_TRANS}->{rd});
    #print UNSAFE "# evDrift on $b:\n".cfg2cmd('unsafe/',$b,$d->{$b}->{BEST_DRIFTEV}->{rd});
    print UNSAFE cfg2cmd('unsafe/',$b,$d->{$b}->{BEST_DRIFTEV}->{rd});
}
close BODY;
close SCRIPT;
close UNSAFE;
print "wrote: exp-body.tex\n";
print "wrote: generate_table1\n";
print "wrote: runall_unsafe\n";

# calculate the speedup on the ones that Drift and evDrift BOTH solved
my @driftTimes  = map { $d->{$_}->{BEST_TRANS}->{cpu} } @bothSolved;
my @evDiftTimes = map { $d->{$_}->{BEST_DRIFTEV}->{cpu} } @bothSolved;
# print "GM of evtrans:".Dumper(\@geos_evtrans, 0+@geos_evtrans);
# print "GM of direct:".Dumper(\@geos_direct, 0+@geos_direct);
# print "times:".Dumper(\@driftTimes, \@evDiftTimes);
my $speedupEVoverDrift = geometric_mean(@driftTimes)/geometric_mean(@evDiftTimes);



### Generate trace partition comparison

# compute the best run set (only non-ev trans)
foreach my $bench (sort keys %$d) {
    # choose a starting point for both BEST_TRANS and BEST_DRIFTEV
    # my $someRD = (grep($_ !~ /mochi/ && $_ =~ /trans/,keys %{$d->{$bench}}))[0];
    # newBest('BEST_TRANS',$bench,$someRD);
    # my $someRD = (grep($_ !~ /mochi/ && $_ !~ /trans/,keys %{$d->{$bench}}))[0];
    # newBest('BEST_DRIFTEV',$bench,$someRD);
    
    foreach my $rd (keys %{$d->{$bench}}) {
        next if $rd =~ /BEST/;
        next if $rd =~ /mochi/i;
        #next if $rd =~ /TRtrans/;
        next if $rd !~ /TL1/; # CA on June 25th said for TP only do TL=1
        my $BEST = ($rd =~ /TPfalse/i ? 'BEST_TPOFF' : 'BEST_TPON');
        $BEST = $BEST.($rd =~ /TRtrans/ ? '_DRIFT' : '_EVDRIFT');
        # we have nothing yet, so we take it
        if (not defined $d->{$bench}->{$BEST}) {
            newBest($BEST,$bench,$rd);
        # does it improve because previously BEST coudln't prove it?
        } elsif ($d->{$bench}->{$BEST}->{res} ne 'true') {
            newBest($BEST,$bench,$rd);
        # does it improve because it's faster?
        } elsif ($d->{$bench}->{$rd}->{res} eq 'true'
                && $d->{$bench}->{$rd}->{cpu} < $d->{$bench}->{$BEST}->{cpu}) {
            newBest($BEST,$bench,$rd);
        } else {
            # warn "not better\n";
        }
    }
}

open TP, ">exp-tp.tex" or die $!;
open SCRIPT, ">generate_table2" or die $!;
$ct = 1;
my $newTPOverNoTPevDrift = 0;
my @geos_notp_drift;   my @geos_tp_drift; 
my @geos_notp_evdrift; my @geos_tp_evdrift;
foreach my $b (sort keys %$d) {
    my $tt = $b; $tt =~ s/\_/\\_/g;
    $tt =~ s/negated/neg/;
    print TP "$ct. \\texttt{\\scriptsize $tt} "; ++$ct;
    #warn "tool rd: ".Dumper($b,$d->{$b},$d->{$b}->{BEST_TRANS},$d->{$b}->{BEST_TRANS}->{rd});
    # Best Drift+TP
    print TP sprintf("& %-5s & %3.1f & %3.1f & %s ",
           cleanRes($d->{$b}->{BEST_TPON_DRIFT}->{res}),
           $d->{$b}->{BEST_TPON_DRIFT}->{cpu},
           $d->{$b}->{BEST_TPON_DRIFT}->{mem},
           run2tool($d->{$b}->{BEST_TPON_DRIFT}->{rd}));
    # Best EVDrift no TP
    print TP sprintf("& %-5s & %3.1f & %3.1f & %s ",
           cleanRes($d->{$b}->{BEST_TPOFF_EVDRIFT}->{res}),
           $d->{$b}->{BEST_TPOFF_EVDRIFT}->{cpu},
           $d->{$b}->{BEST_TPOFF_EVDRIFT}->{mem},
           run2tool($d->{$b}->{BEST_TPOFF_EVDRIFT}->{rd}));
    # Best EVDrift+TP
    print TP sprintf("& %-5s & %3.1f & %3.1f & %s \\\\ \n",
           cleanRes($d->{$b}->{BEST_TPON_EVDRIFT}->{res}),
           $d->{$b}->{BEST_TPON_EVDRIFT}->{cpu},
           $d->{$b}->{BEST_TPON_EVDRIFT}->{mem},
           run2tool($d->{$b}->{BEST_TPON_EVDRIFT}->{rd}));

    # save the runtimes for statistics
    push @geos_notp_drift, $d->{$b}->{BEST_TPOFF_DRIFT}->{cpu}
      if $d->{$b}->{BEST_TPOFF_DRIFT}->{cpu} < 900 && $d->{$b}->{BEST_TPOFF_DRIFT}->{cpu} > 0;
    push @geos_tp_drift, $d->{$b}->{BEST_TPON_DRIFT}->{cpu}
      if $d->{$b}->{BEST_TPON_DRIFT}->{cpu} < 900 && $d->{$b}->{BEST_TPON_DRIFT}->{cpu} > 0;
    push @geos_notp_evdrift, $d->{$b}->{BEST_TPOFF_EVDRIFT}->{cpu}
      if $d->{$b}->{BEST_TPOFF_EVDRIFT}->{cpu} < 900 && $d->{$b}->{BEST_TPOFF_EVDRIFT}->{cpu} > 0;
    push @geos_tp_evdrift, $d->{$b}->{BEST_TPON_EVDRIFT}->{cpu}
      if $d->{$b}->{BEST_TPON_EVDRIFT}->{cpu} < 900 && $d->{$b}->{BEST_TPON_EVDRIFT}->{cpu} > 0;
    #
    $newTPOverNoTPevDrift++ if $d->{$b}->{BEST_TPON_EVDRIFT}->{res} eq 'true' && $d->{$b}->{BEST_TPOFF_EVDRIFT}->{res} ne 'true';
    # script for tp-vs-noTP
    print SCRIPT "# Drift + Trace partitioning $b:\n".cfg2cmd('',$b,$d->{$b}->{BEST_TPON_DRIFT}->{rd});
    print SCRIPT "# evDrift without Trace partitioning $b:\n".cfg2cmd('',$b,$d->{$b}->{BEST_TPOFF_EVDRIFT}->{rd});
    print SCRIPT "# evDrift + Trace partitioning $b:\n".cfg2cmd('',$b,$d->{$b}->{BEST_TPOFF_EVDRIFT}->{rd});
}
close TP;
close SCRIPT;
print "wrote: exp-tp.tex\n";
print "wrote: generate_table2\n";


use Statistics::Basic qw(:all);
open STATS, ">exp-stats.tex" or die $!;
print STATS join("\n", (
   ('\newcommand\expGMevtrans{'.geometric_mean(@geos_evtrans).'}'),
   ('\newcommand\expGMcoarmochi{'.geometric_mean(@geos_coarmochi).'}'),
   ('\newcommand\expGMrealmochi{'.geometric_mean(@geos_realmochi).'}'),
   ('\newcommand\expGMdirect{'.geometric_mean(@geos_direct).'}'),
   ('\newcommand\expSpeedupEVoverDrift{'.$speedupEVoverDrift.'}'),
#   ('\newcommand\expSpeedupEvtrans{'.sprintf("%0.1f", geometric_mean(@geos_evtrans)/geometric_mean(@geos_direct)).'}'),
#   ('\newcommand\expSpeedupMochi{'.sprintf("%0.1f", geometric_mean(@geos_mochi)/geometric_mean(@geos_direct)).'}'),
   ('\newcommand\expNewOverCoarMochi{'.$newOverCoarMochi.'}'),
   ('\newcommand\expNewOverRealMochi{'.$newOverRealMochi.'}'),
   ('\newcommand\expNewOverTrans{'.$newOverTrans.'}'),
   ('\newcommand\expBenchCount{'.$benchCount.'}'),
   ('\newcommand\expDriftVerified{'.$driftVerified.'}'),
   ('\newcommand\expEDriftVerified{'.$evdriftVerified.'}'),
   "% TP Improvements:",
   ('\newcommand\expTPGMoffDrift{'.geometric_mean(@geos_notp_drift).'}'),
   ('\newcommand\expTPGMonDrift{'.geometric_mean(@geos_tp_drift).'}'),
   ('\newcommand\expTPGMoffevDrift{'.geometric_mean(@geos_notp_evdrift).'}'),
   ('\newcommand\expTPGMonevDrift{'.geometric_mean(@geos_tp_evdrift).'}'),
   ('\newcommand\expTPSpeedupDrift{'.sprintf("%0.1f", geometric_mean(@geos_notp_drift)/geometric_mean(@geos_tp_drift)).'}'),
   ('\newcommand\expTPSpeedupevDrift{'.sprintf("%0.1f", geometric_mean(@geos_notp_evdrift)/geometric_mean(@geos_tp_evdrift)).'}'),
   ('\newcommand\expTPNew{'.$newTPOverNoTPevDrift.'}'),
   "% Overview 1st example:",
   ('\newcommand\expBestOverviewEVDrift{'.sprintf("%0.1f", $d->{overview1}->{BEST_DRIFTEV}->{cpu}).'}'),
   ('\newcommand\expBestOverviewTrans{'.sprintf("%0.1f", $d->{overview1}->{BEST_TRANS}->{cpu}).'}'),
   "% Overview temperature example:",
   ('\newcommand\expBestTempEVDrift{'.sprintf("%d", $d->{temperature}->{BEST_DRIFTEV}->{cpu}).'}'),
   ('\newcommand\expBestTempTrans{'.sprintf("%d", $d->{temperature}->{BEST_TRANS}->{cpu}).'}'),
))."\n";
close STATS;
print "wrote: exp-stats.tex\n" or die $!;


# while(<DATA>) {
#     next if /^tool/;
#     next if /^run set/;
#     next if /\tstatus\t/;
#     my ($fn,$res,$cpu,$wall,$mem) = split /\t/, $_;
#     $fn =~ s/^cps_//;
#     $fn =~ s/_/\\_/g;
#     printf("%-30s & %-5s & %0.2f & %0.2f & %0.2f \\\\\n",
#         $fn, cleanRes($res), $cpu, $wall, $mem);
# }

__DATA__
tool	coarmochi NO_VERSION_UTIL	coarmochi NO_VERSION_UTIL	coarmochi NO_VERSION_UTIL	coarmochi NO_VERSION_UTIL
run set	default.mochibenchmarks	default.mochibenchmarks	default.mochibenchmarks	default.mochibenchmarks
../../tests/effects/mochi/	status	cputime (s)	walltime (s)	memory (MB)
cps_acc-pos-net0-negated.ml	OUT OF MEMORY	39.561118434	39.52044827118516	999.997440
cps_acc-pos-net0-similar-negated.ml	OUT OF MEMORY	40.443142798	40.41010303609073	999.997440
cps_acc-pos-net0-similar.ml	TIMEOUT	900.251731749	900.2475049868226	454.119424
cps_acc-pos-net0.ml	TIMEOUT	900.254324895	900.2498775236309	448.516096
cps_all-ev-even-sink.ml	unknown	0.031445387	0.0340123288333416	35.680256
cps_assert-true.ml	unknown	4.797628357	4.7890766356140375	92.082176
cps_depend.ml	OUT OF MEMORY	57.696388143	57.63335299119353	999.997440
cps_disj.ml	OUT OF MEMORY	237.340026792	237.0736487712711	999.997440
cps_ho-shrink.ml	TIMEOUT	900.261575017	900.1133371777833	999.997440
cps_last-ev-even.ml	unknown	3.632835373	3.6285442896187305	99.291136
cps_max-min.ml	TIMEOUT	900.272918367	900.2402329705656	999.997440
cps_min-max.ml	TIMEOUT	900.2684614	900.2167596127838	999.997440
cps_order-irrel.ml	unknown	18.950768298	18.91433823108673	143.339520
cps_resource-analysis.ml	TIMEOUT	900.253579096	900.2900423351675	270.442496
cps_sum-appendix.ml	unknown	0.036942231	0.03894921950995922	36.855808
cps_sum-of-ev-even.ml	unknown	3.27330404	3.268652807921171	88.887296
cps_traffic_light_fo_simple.ml	OUT OF MEMORY	254.436113917	254.29541855305433	999.997440
table-generator results/benchmark-drift.2024-02-25_12-16-28.results.drift-new-len0.effects.xml.bz2 results/benchmark-drift.2024-02-25_12-16-28.results.drift-new-len1.effects.xml.bz2 results/benchmark-drift.2024-02-25_12-16-28.results.drift-trans-len0.effects.xml.bz2 results/benchmark-drift.2024-02-25_12-16-28.results.drift-trans-len1.effects.xml.bz2
